package smallbasis

import (
	"image"
	"math"
	"sort"

	"github.com/unixpickle/num-analysis/ludecomp"
)

const DefaultBlockSize = 64

// A Compressor compresses and decompresses images by changing
// each block of an image into a different linear basis and
// then removing basis vectors that aren't used very heavily.
type Compressor struct {
	quality float64
	basis   *ludecomp.Matrix
	basisLU *ludecomp.LU

	blockSize int
}

// NewCompressorBasis creates a Compressor that uses a custom
// block size, quality, and basis.
//
// The quality argument ranges from 0 to 1 and indicates the
// fraction of the basis elements that should be used in the
// compressed image without being pruned.
//
// Since the Compressor works on blocks of an image at a time,
// the blockSize specifies the size of the blocks it works on.
// Each blockSize-by-blockSize chunk of each input image will
// be compressed separately.
//
// The basis matrix is a matrix of column vectors.
// A basis will work best if its columns are normalized,
// but it needn't be orthonormal.
func NewCompressorBasis(quality float64, blockSize int, basis *ludecomp.Matrix) *Compressor {
	return &Compressor{
		quality:   quality,
		basis:     basis,
		basisLU:   ludecomp.Decompose(basis),
		blockSize: blockSize,
	}
}

// NewCompressorBlockSize is like NewCompressionBasis, but it
// uses a basis generated by BasisMatrix.
func NewCompressorBlockSize(quality float64, blockSize int) *Compressor {
	basis := BasisMatrix(blockSize * blockSize)
	return NewCompressorBasis(quality, blockSize, basis)
}

// NewCompressor is like NewCompressorBlockSize, but uses
// DefaultBlockSize.
func NewCompressor(quality float64) *Compressor {
	return NewCompressorBlockSize(quality, DefaultBlockSize)
}

// Compress compresses an image and returns binary data
// representing the result.
func (c *Compressor) Compress(i image.Image) []byte {
	blocks := c.blocksInImage(i)
	r := &RankedVectors{
		BasisIndices: make([]int, c.blockSize*c.blockSize),
		CoeffTotal:   make([]float64, c.blockSize*c.blockSize),
	}
	for i := range r.BasisIndices {
		r.BasisIndices[i] = i
	}
	for _, block := range blocks {
		solution := c.basisLU.Solve(block)
		for i, coeff := range solution {
			r.CoeffTotal[i] += math.Abs(coeff)
		}
	}

	sort.Sort(r)
	basisCount := roundFloat(c.quality * float64(c.blockSize*c.blockSize))
	usedBasis := make([]int, basisCount)
	copy(usedBasis, r.BasisIndices)
	sort.Ints(usedBasis)

	basisVectors := make([]ludecomp.Vector, len(usedBasis))
	for i, x := range usedBasis {
		vec := make(ludecomp.Vector, c.blockSize*c.blockSize)
		for j := range vec {
			vec[j] = c.basis.Get(x, j)
		}
		basisVectors[i] = vec
	}

	projBlocks := c.projectionBlocks(basisVectors, blocks)

	compressed := &compressedImage{
		UsedBasis: usedBasis,
		Blocks:    projBlocks,
		BlockSize: c.blockSize,
		Width:     i.Bounds().Dx(),
		Height:    i.Bounds().Dy(),
	}
	return compressed.Encode()
}

// projectionBlocks projects the blocks onto a pruned basis.
// The returned blocks hold the coefficients for the linear
// combination of basis elements that get as close to each
// original block as possible (i.e. that arrive at an
// orthogonal projection).
func (c *Compressor) projectionBlocks(basis, blocks []ludecomp.Vector) [][]float64 {
	// If we have an equation Ax=b where A is the matrix with
	// our pruned basis for columns, then we would like to find
	// the x which minimizes the magnitude ||Ax-b||. To do this,
	// we multiply on the left by the transpose of A, giving
	// (A^T)Ax = (A^T)b.

	// projLeft corresponds to (A^T)A in the above explanation.
	projLeft := ludecomp.NewMatrix(len(basis))
	for i, v := range basis {
		for j, u := range basis {
			dot := v.Dot(u)
			projLeft.Set(i, j, dot)
		}
	}

	projLeftLU := ludecomp.Decompose(projLeft)

	res := make([][]float64, len(blocks))
	for i, block := range blocks {
		// blockDot corresponds to (A^T)b in the explanation above.
		blockDot := make(ludecomp.Vector, len(basis))
		for k := range blockDot {
			blockDot[k] = basis[k].Dot(block)
		}
		solution := projLeftLU.Solve(blockDot)
		res[i] = []float64(solution)
	}

	return res
}

func (c *Compressor) blocksInImage(i image.Image) []ludecomp.Vector {
	numCols := i.Bounds().Dx() / c.blockSize
	if i.Bounds().Dx()%c.blockSize != 0 {
		numCols++
	}

	numRows := i.Bounds().Dy() / c.blockSize
	if i.Bounds().Dy()%c.blockSize != 0 {
		numRows++
	}

	res := make([]ludecomp.Vector, 3*numRows*numCols)
	for row := 0; row < numRows; row++ {
		for col := 0; col < numCols; col++ {
			startX := i.Bounds().Min.X + col*c.blockSize
			startY := i.Bounds().Min.Y + row*c.blockSize
			blocks := make([]ludecomp.Vector, 3)
			for i := range blocks {
				blocks[i] = make(ludecomp.Vector, c.blockSize*c.blockSize)
			}
			for y := 0; y < c.blockSize; y++ {
				if y+startY >= i.Bounds().Max.Y {
					continue
				}
				for x := 0; x < c.blockSize; x++ {
					if x+startX >= i.Bounds().Max.X {
						continue
					}
					px := i.At(x, y)
					r, g, b, _ := px.RGBA()
					idx := x + y*c.blockSize
					blocks[0][idx] = float64(r) / 0xffff
					blocks[1][idx] = float64(g) / 0xffff
					blocks[2][idx] = float64(b) / 0xffff
				}
			}
			res = append(res, blocks...)
		}
	}

	return res
}

type RankedVectors struct {
	BasisIndices []int
	CoeffTotal   []float64
}

func (r *RankedVectors) Len() int {
	return len(r.BasisIndices)
}

func (r *RankedVectors) Less(i, j int) bool {
	return r.CoeffTotal[i] > r.CoeffTotal[j]
}

func (r *RankedVectors) Swap(i, j int) {
	r.CoeffTotal[i], r.CoeffTotal[j] = r.CoeffTotal[j], r.CoeffTotal[i]
	r.BasisIndices[i], r.BasisIndices[j] = r.BasisIndices[j], r.BasisIndices[i]
}
